// Generated by CoffeeScript 1.8.0
var Buffer, PassThrough, Stream, When, bindCallback, fs, nodefn, path, rawBody, streamToBuffer, tmpFilename, _ref;

rawBody = require('raw-body');

When = require('when');

path = require('path');

fs = require('fs');

nodefn = (function() {
  try {
    return require('when/node');
  } catch (_error) {
    return require('when/node/function');
  }
})();

Buffer = require('buffer').Buffer;

_ref = require('stream'), Stream = _ref.Stream, PassThrough = _ref.PassThrough;

streamToBuffer = nodefn.lift(rawBody);

PassThrough || (PassThrough = require('through'));

tmpFilename = function(ext) {
  var base, tmpDir;
  if (ext == null) {
    ext = 'tmp';
  }
  tmpDir = process.env.TMPDIR || '/tmp';
  base = Math.random().toString(36).slice(2, 12);
  return path.resolve(tmpDir, "node-webp-" + base + "." + ext);
};

bindCallback = function(promise, next) {
  if (typeof next === 'function') {
    return nodefn.bindCallback(promise, next);
  } else {
    return promise;
  }
};

module.exports = {
  _createFileSource: function() {
    var deferred, done, filename, promise, reject, resolve, stream, _ref1;
    if (this._tmpFilename) {
      return this._tmpFilename;
    }
    filename = tmpFilename();
    done = Buffer.isBuffer(this.source) ? nodefn.call(fs.writeFile, filename, this.source) : this.source instanceof Stream ? ((_ref1 = When.defer(), resolve = _ref1.resolve, reject = _ref1.reject, promise = _ref1.promise, _ref1), deferred = When.defer(), stream = fs.createWriteStream(filename).once('error', reject).once('close', resolve).once('finish', resolve), this.source.pipe(stream), promise.ensure(function() {
      stream.removeListener('error', reject);
      stream.removeListener('close', resolve);
      return stream.removeListener('finish', resolve);
    })) : When.reject(new Error('Mailformed source'));
    return this._tmpFilename = done.then(function() {
      return filename;
    });
  },
  _cleanup: function() {
    var promise;
    if (!(promise = this._tmpFilename)) {
      return;
    }
    delete this._tmpFilename;
    return When(promise).then(function(filename) {
      if (filename) {
        return nodefn.call(fs.unlink, filename);
      }
    }).otherwise(function() {});
  },
  _fileSource: function() {
    if (typeof this.source === 'string') {
      return this.source;
    } else {
      return this._createFileSource();
    }
  },
  _write: function(source, outname) {
    var args, res, stdin, stdout;
    outname || (outname = '-');
    stdin = typeof source !== 'string';
    stdout = outname === '-';
    args = [].concat(this.args(), ['-o', outname, '--', (stdin ? '-' : source)]);
    if (!stdin) {
      return this._spawn(args, stdin, stdout);
    } else if (Buffer.isBuffer(source)) {
      res = this._spawn(args, stdin, stdout);
      res.stdin.end(source);
      return res;
    } else if (source instanceof Stream) {
      res = this._spawn(args, stdin, stdout);
      source.pipe(res.stdin);
      return res;
    } else {
      return {
        promise: When.reject(new Error('Mailformed source'))
      };
    }
  },
  write: function(outname, next) {
    var promise;
    promise = !outname ? When.reject(new Error('outname in not specified')) : this._stdin ? (this._write(this.source, outname)).promise : When(this._fileSource()).then((function(_this) {
      return function(filename) {
        return (_this._write(filename, outname)).promise;
      };
    })(this)).ensure((function(_this) {
      return function() {
        return _this._cleanup();
      };
    })(this));
    return bindCallback(promise, next);
  },
  toBuffer: function(next) {
    return bindCallback(streamToBuffer(this.stream()), next);
  },
  _stream: function(source, outstream) {
    var res;
    res = this._write(source, '-');
    if (res.stdout) {
      res.stdout.pipe(outstream, {
        end: false
      });
      return res.promise;
    } else {
      return res.promise.then(function() {
        return When.reject(new Error('Failed to pipe stdout'));
      });
    }
  },
  stream: function() {
    var promise, res;
    res = new PassThrough();
    promise = this._stdin ? this._stream(this.source, res) : When(this._fileSource()).then((function(_this) {
      return function(filename) {
        return _this._stream(filename, res);
      };
    })(this)).ensure((function(_this) {
      return function() {
        return _this._cleanup();
      };
    })(this));
    promise.then(function() {
      return res.end();
    }).otherwise(function(err) {
      return res.emit('error', err);
    });
    return res;
  }
};
